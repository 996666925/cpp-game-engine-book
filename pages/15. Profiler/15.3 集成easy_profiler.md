## 15.3 集成easy_profiler

上一节将介绍了将`easy_profiler`编译为库，现在可以集成到引擎了。

### 1. 初始化监听

代码如下：

```c++
///file:source/utils/application.cpp line:68

/// 初始化
void Application::Init() {
    EASY_MAIN_THREAD;
    profiler::startListen();// 启动profiler服务器，等待gui连接。
    ......
}
```

引擎中存在多个线程，使用`EASY_MAIN_THREAD`来标记这里是主线程，这个宏展开如下：

```c++
# define EASY_MAIN_THREAD EASY_THREAD("Main")
```

那么其他线程，例如文件加载线程就可以这样标记：`EASY_THREAD("Load")`。

游戏端是作为`easy_profiler`的Server端，监听`profiler_gui.exe`的连接，所以启动游戏时就要调用`profiler::startListen()`，等待连接。

### 2. 收集每帧的函数耗时

在主循环里，使用`EASY_BLOCK`标记代码块，就可以收集这段代码(一帧)的性能数据。

```c++
///file:source/utils/application.cpp line:148

void Application::Run() {
    while (true)
    {
        EASY_BLOCK("Frame"){
            if(glfwWindowShouldClose(glfw_window_)){
                break;
            }
            Update();
            Render();

            EASY_BLOCK("glfwSwapBuffers"){
                glfwSwapBuffers(glfw_window_);
            }
            EASY_END_BLOCK;

            EASY_BLOCK("glfwPollEvents"){
                glfwPollEvents();
            }
            EASY_END_BLOCK;
        }EASY_END_BLOCK;
    }
    ......
}
```

然后再使用 `EASY_FUNCTION` 标记 `Update`、`Render` 这2个函数。

```c++
///file:source/utils/application.cpp line:112

void Application::Update(){
    EASY_FUNCTION(profiler::colors::Magenta); // 标记函数
    ......
}
```

现在我就收集了一帧的性能信息，而且有调用层次：

```c++
>Frame
-->Update
-->Render
-->glfwSwapBuffers
-->glfwPollEvents
```

### 3. 测试




