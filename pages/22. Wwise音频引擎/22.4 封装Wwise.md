## 22.4 封装Wwise

这一节介绍`AudioSource`、`AudioListener`对Wwise API的封装。

+ AudioSource
  
  音源，提供创建、播放、停止、设置回调等接口，是对Wwise Event的封装。

+ AudioListener
  
  听者。

在`22.2 Wwise制作音效导出SoundBank`这一节，制作了一个死亡音效并导出了SoundBank，这一节就用这个死亡音效来作为实例播放。

### 1. AudioSource

Wwise提供了接口 `AK::SoundEngine::PostEvent`来触发Event播放音效，并且返回 `AkPlayingID` 来作为当前正在播放的Event的Handle。

所以在AudioSource里，主要是提供对Event的播放，以及后续对`AkPlayingID`的后续操作。


```c++
//file:source/audio/wwise/audio_source.h

class AudioSource:public Component {
public:
    AudioSource();
    ~AudioSource();

    /// 设置Event名
    void SetEvent(const std::string &event_name);

    /// 设置实时控制参数
    void SetRTPCValue(const std::string &realtime_parameter_control_name, float value);

    /// 播放
    void Play();

    /// 停止
    void Stop();

    void set_event_end_callback(std::function<void(void)> callback){
        event_end_callback_ = callback;
    }

private:
    void Awake() override;
    void Update() override;

private:
    AkGameObjectID audio_object_id_;
    std::string event_name_;
    AkPlayingID playing_id_;

    std::function<void()> event_end_callback_;//AudioSource实例播放结束回调

    /********************  回调处理  ********************/
public:
    /// Event回调，静态函数
    /// \param in_eType Event类型。
    /// \param in_pCookie 回调参数，在PostEvent设置的，原样返回。
    static void MusicCallback(AkCallbackType in_eType,AkCallbackInfo* in_pCallbackInfo);

    /// 处理AudioSource回调队列
    static void ExecuteMusicCallbackQueue();
private:
    /// Event回调信息
    class MusicCallbackInfo{
    public:
        MusicCallbackInfo(AkCallbackType callback_type, AkCallbackInfo callback_info)
                :callback_type_(callback_type), callback_info_(callback_info){}
        ~MusicCallbackInfo(){}

        AkCallbackType callback_type_;//回调类型，停止、暂停、退出等事件枚举
        AkCallbackInfo callback_info_;//回调参数，包括音频对象ID、透传参数。
    };

    static rigtorp::SPSCQueue<MusicCallbackInfo> event_callback_queue_;//AudioSource回调队列，单线程写单线程读，线程安全。
};
```

`SetEvent` `Play` `Stop` 这几个API都挺简单的，就是调用上一节介绍的WwiseAudio 对应函数。

需要详细介绍的是：

<font color=red>播放音效设置的事件监听回调，回调函数是在Wwise线程，不是在主线程。</font>

![](../../imgs/audio_wwise/integrate/callback_call_in_thread.jpg)

那么需要用一个多线程共享队列来存储事件回调，然后在主线程Update从队列中取出事件回调来处理。

```c++
//file:source/audio/wwise/audio_source.h line:68

private:
    /// Event回调信息
    class MusicCallbackInfo{
    public:
        MusicCallbackInfo(AkCallbackType callback_type, AkCallbackInfo callback_info)
                :callback_type_(callback_type), callback_info_(callback_info){}
        ~MusicCallbackInfo(){}

        AkCallbackType callback_type_;//回调类型，停止、暂停、退出等事件枚举
        AkCallbackInfo callback_info_;//回调参数，包括音频对象ID、透传参数。
    };

    static rigtorp::SPSCQueue<MusicCallbackInfo> event_callback_queue_;//AudioSource回调队列，单线程写单线程读，线程安全。
```

这里引入`rigtorp::SPSCQueue`这个库，它是多线程安全的，支持一个生产者，一个消费者同时访问。

当Wwise调用回调函数时，实例化 `MusicCallbackInfo`，然后存入`event_callback_queue_`。

```c++
//file:source/audio/wwise/audio_source.cpp line:67

/// Event回调，静态函数
/// \param in_eType Event类型。
/// \param in_pCookie 回调参数，在PostEvent设置的，原样返回。
void AudioSource::MusicCallback(AkCallbackType in_eType,AkCallbackInfo* in_pCallbackInfo)
{
    MusicCallbackInfo music_callback_info(in_eType,*in_pCallbackInfo);
    event_callback_queue_.push(music_callback_info);
}

/// 处理AudioSource回调队列
void AudioSource::ExecuteMusicCallbackQueue() {
    while (event_callback_queue_.front()){
        MusicCallbackInfo* music_callback_info = event_callback_queue_.front();

        AudioSource* audio_source=(AudioSource*)music_callback_info->callback_info_.pCookie;
        if(music_callback_info->callback_type_ == AK_EndOfEvent){
            DEBUG_LOG_INFO("end event: {}",audio_source->event_name_);
            if(audio_source->event_end_callback_){
                audio_source->event_end_callback_();
            }
        }
        event_callback_queue_.pop();
    }
}
```

然后在主线程Update时，从队列中取出，再处理。

```c++
//file:source/audio/wwise/audio_source.cpp line:54

void AudioSource::Update() {
    Component::Update();

    // 处理Event
    ExecuteMusicCallbackQueue();
    ......
}
```

另外需要在Update里面更新Wwise GameObject的坐标以及朝向，不然得不到3D音效。

### 2. AudioListener

AudioListener只是一个坐标抽象表示，所以只需要创建Wwise GameObject。

也需要在Update里面更新Wwise GameObject的坐标以及朝向。

```c++
//file:source/audio/wwise/audio_listener.cpp

void AudioListener::Awake() {
    audio_listener_object_id_=WwiseAudio::GeneratorGameObjectID();
    WwiseAudio::CreateAudioObject(audio_listener_object_id_,game_object()->name().c_str());
    WwiseAudio::SetDefaultListeners(audio_listener_object_id_);
}

void AudioListener::Update() {
    Component::Update();
    auto component_transform=game_object()->GetComponent("Transform");
    auto transform=dynamic_cast<Transform*>(component_transform);
    if(!transform){
        return;
    }
    auto pos=transform->position();
    // 设置Wwise GameObject位置、朝向
    WwiseAudio::SetPosition(audio_listener_object_id_,pos,glm::vec3(0,0,1),glm::vec3(0,1,0));
}
```

### 3. 实例

在`22.2 Wwise制作音效导出SoundBank`这一节，制作了的死亡音效。

现在测试加载了导出的Bank，并创建`AudioSource`、`AudioListener`实例，触发Event播放音效。



