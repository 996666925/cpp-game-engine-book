## 21.1 基于任务队列的多线程渲染

上一节测试了GLFW对多线程的支持，证实了在单独子线程调用OpenGL API渲染是可行的。

那么这一节就来对其进行细化，将渲染三角形这一目标，拆分多个子任务，主线程以命令的形式与渲染线程进行通信。

任务可以拆分为任务命令和任务参数。

* 案例一

    你在蹲坑，发现没有纸了，打电话叫你老婆拿纸，这是一个任务。

    任务命令：拿纸

    任务参数：无

    你是主线程，发出命令。

    老婆是渲染线程，接受命令，执行，给你结果。

    这是一个阻塞式任务，你(主线程)必须等老婆(渲染线程)执行任务(拿纸)，返回结果(给你纸)。

    就如下面图中的`编译Shader`命令。

    ![](../../imgs/multithread_render/multithread_render/multithread_render.jpg)

* 案例二

    你在外面闲逛，你老婆打电话过来叫你去买一斤西瓜，这是一个任务。

    任务命令：买东西

    任务参数有2个：物品：西瓜 重量：一斤

    老婆是主线程，发出命令并带参数。

    你是渲染线程，接受命令，解析参数，执行。

    买西瓜是比较复杂的操作，要去多个店里询问，比价，拿西瓜，称重，最后付款，才算完成了买西瓜这个任务。

    老婆(主线程)不管这些步骤，她只要发命令，然后等结果。

    这是一个非阻塞任务，老婆不会一直等你买瓜回去，她可能在打王者荣耀。

    等你买好瓜到家，老婆又发出命令，让你去切瓜。

    主线程发出渲染命令后，也不会等渲染结果，而是转身就去执行其他逻辑。

    就如案例一图中的`绘制`命令。

* 案例三
    
    你老婆在蹲坑，没有纸了，打电话叫你拿纸，叫你买一斤西瓜，然后再去拿两个顺丰快递，然后再去取1000块钱。

    第一个是阻塞任务，然后几个都是非阻塞任务。

    命令太多，参数太多，人到中年，记忆力衰退，你记不住了。
    
    你需要一个任务队列来保存这些任务，然后从任务队列里面取任务来做。

    就如同下图，`编译shader`是阻塞性任务，完成之后才能去做`绘制`这个非阻塞任务。

    ![](../../imgs/multithread_render/render_task_queue/render_task_queue.jpg)

那么案例三是我们所需要的，来看下如何实现。

### 1. 渲染任务

非阻塞性任务由 `任务命令` `任务参数` 组成。

阻塞性任务由 `任务命令` `任务参数` `结果` 组成。

```c++
/// 渲染命令
enum RenderCommand {
    COMPILE_SHADER,//编译着色器
    DRAW_ARRAY,//绘制
};

/// 渲染任务基类
class RenderTaskBase{
public:
    RenderTaskBase(){}
    virtual ~RenderTaskBase(){}
public:
    RenderCommand render_command_;//渲染命令
    bool need_return_result = false;//是否需要返回结果
};

/// 需要结果的阻塞性任务
class RenderTaskNeedReturnResult: public RenderTaskBase{
public:
    RenderTaskNeedReturnResult(){need_return_result=true;}
    ~RenderTaskNeedReturnResult(){}
};
```

对于阻塞性任务，将`need_return_result`设置为`true`，当在渲染线程中处理这个任务时，要设置回传的参数，主线程则一直等待这个任务执行完毕才继续下一步。

```c++
/// 编译着色器任务
class RenderTaskCompileShader: public RenderTaskNeedReturnResult{
public:
    RenderTaskCompileShader(){}
    ~RenderTaskCompileShader(){}
public:
    const char* vertex_shader_source_= nullptr;
    const char* fragment_shader_source_= nullptr;
public:
    GLuint result_program_id_=0;//存储编译Shader结果的ProgramID
};

/// 绘制任务
class RenderTaskDrawArray: public RenderTaskBase {
public:
    RenderTaskDrawArray(){}
    ~RenderTaskDrawArray(){}
public:
    GLuint program_id_=0;//着色器ProgramID
    const void* positions_=nullptr;//顶点位置
    GLsizei   positions_stride_=0;//顶点数据大小
    const void* colors_=nullptr;//顶点颜色
    GLsizei   colors_stride_=0;//颜色数据大小
};
```

例如编译着色器任务，在渲染线程编译着色器之后，需要将编译Shader结果的`ProgramID`设置到 `result_program_id_`，主线程拿到它之后，才能继续渲染。

而绘制任务是非阻塞性的，绘制一个三角形也没有什么好返回的，主线程源源不断的发出任务，渲染线程不断取出，然后执行即可。

```c++
Renderer* renderer;
RenderTaskCompileShader* render_task_compile_shader;
GLuint program_id_=0;
int main(void)
{
    //设置错误回调
    glfwSetErrorCallback(error_callback);

    if (!glfwInit())
        exit(EXIT_FAILURE);

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);

    //创建窗口
    GLFWwindow* window = glfwCreateWindow(960, 640, "Simple example", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        exit(EXIT_FAILURE);
    }

    //创建Renderer(独立线程)
    renderer=new Renderer(window);

    //编译Shader任务
    render_task_compile_shader=new RenderTaskCompileShader();
    {
        render_task_compile_shader->render_command_=RenderCommand::COMPILE_SHADER;
        //构造参数
        render_task_compile_shader->vertex_shader_source_=vertex_shader_text;
        render_task_compile_shader->fragment_shader_source_=fragment_shader_text;
        render_task_compile_shader->need_return_result=true;//需要返回结果
    }
    renderer->PushRenderTask(render_task_compile_shader);

    while (!glfwWindowShouldClose(window))
    {
        Render();

        //非渲染相关的API，例如处理系统事件，就放到主线程中。
        glfwPollEvents();

        //判断渲染线程完成了这一帧所有的渲染任务
        while(renderer->IsQueueEmpty()==false){}
    }

    delete renderer;
    ......
}

void Render(){
    if(program_id_==0){//等待Renderer线程编译Shader，并返回结果
        program_id_=render_task_compile_shader->result_program_id_;
        if(program_id_>0){
            delete render_task_compile_shader;//需要等待结果的渲染任务，需要在获取结果后删除。
        }else{
            return;
        }
    }

    //绘制任务
    RenderTaskDrawArray* render_task_draw_array=new RenderTaskDrawArray();
    {
        render_task_draw_array->render_command_=RenderCommand::DRAW_ARRAY;
        //构造参数
        render_task_draw_array->program_id_=program_id_;
        render_task_draw_array->positions_=kPositions;
        render_task_draw_array->positions_stride_=sizeof(glm::vec3);
        render_task_draw_array->colors_=kColors;
        render_task_draw_array->colors_stride_=sizeof(glm::vec4);
    }
    renderer->PushRenderTask(render_task_draw_array);
}
```

### 2. 渲染队列

主线程中实例化`Renderer`后，在`Renderer`的构造函数中就创建了渲染线程。

```c++
Renderer::Renderer(GLFWwindow *window):window_(window), render_task_queue_(1024) {
    render_thread_ = std::thread(&Renderer::RenderMain, this);
    render_thread_.detach();
}

Renderer::~Renderer() {
    if (render_thread_.joinable()) {
        render_thread_.join();//等待渲染线程结束
    }
}
```

也创建了渲染队列。

渲染队列是一个`ringbuffer`，它是单线程写单线程读安全的，用来放渲染任务最合适不过了。

```c++
class Renderer {
public:
    Renderer(GLFWwindow* window);
    ~Renderer();

    void PushRenderTask(RenderTaskBase* render_task){
        render_task_queue_.push(render_task);
    }

    /// 渲染任务队列是否空，用来判定这一帧渲染完成.
    bool IsQueueEmpty(){
        return render_task_queue_.empty();
    }
private:
    void RenderMain();
private:
    GLFWwindow* window_;
    std::thread render_thread_;//渲染线程
    rigtorp::SPSCQueue<RenderTaskBase*> render_task_queue_;//渲染任务队列
};
```

在渲染线程中，则一直从队列中取任务。

```c++
void Renderer::RenderMain() {
    //渲染相关的API调用需要放到渲染线程中。
    glfwMakeContextCurrent(window_);
    gladLoadGL(glfwGetProcAddress);
    glfwSwapInterval(1);

    while (!glfwWindowShouldClose(window_))
    {
        ......

        if(render_task_queue_.empty()==false){
            RenderTaskBase* render_task = *(render_task_queue_.front());
            switch (render_task->render_command_) {//根据主线程发来的命令，做不同的处理
                case RenderCommand::COMPILE_SHADER:{
                    CompileShader(render_task);
                    break;
                }
                case RenderCommand::DRAW_ARRAY:
                    DrawArray(render_task, projection, view);
                    break;
            }
            render_task_queue_.pop();
            //如果这个任务不需要返回参数，那么用完就删掉。
            if(render_task->need_return_result==false){
                delete render_task;
            }
        }

        std::cout<<"task in queue:"<<render_task_queue_.size()<<std::endl;
        glfwSwapBuffers(window_);
    }
}
```

### 3. 线程同步

主线程发出任务，渲染线程从队列取任务，那么主线程是一定比渲染线程快的。

下一帧的逻辑，可能是需要对上一帧渲染结果做后处理，那么主线程就一定要等待渲染线程这一帧结束。

如果渲染任务特别重，那么渲染线程会比主线程慢很多，主线程就需要一直等待。

这就是在Unity中常见到的`Gfx.WaitForPresent`，CPU正在等待GPU渲染这一帧。

在`Renderer`里提供了`IsQueueEmpty()`这个函数来查询队列是否为空，在主线程可以循环调用它，如果它是空的，说明这一帧已经渲染完成了。

```c++
int main(void)
{
    ......

    while (!glfwWindowShouldClose(window))
    {
        Render();

        //非渲染相关的API，例如处理系统事件，就放到主线程中。
        glfwPollEvents();

        //判断渲染线程完成了这一帧所有的渲染任务
        while(renderer->IsQueueEmpty()==false){}
    }

    ......
}
```







1. 使用spscqueue，逻辑线程向队列添加任务，渲染线程读取任务就就执行。
2. 帧开始与结束的特殊任务，渲染线程拿到结束的任务后，将一个变量设置为帧结束，这样逻辑线程就可以自旋锁等待，然后执行下一个函数，这就是WaitForPresent。

就简单说一下屏幕后期处理的原理，是要等这一帧渲染之后，从FBO拿到渲染的结果，然后再做修改法相、饱和度 这种。

并不是说一个opengl api就一个task，大部分时候都是多个api一起使用，例如编译shader，有很多api调用，但是可以作为一个task，然后这个task接受的参数就是shader源码。

```c++
/// 编译、链接Shader
void compile_shader()
{
    //创建顶点Shader
    vertex_shader = glCreateShader(GL_VERTEX_SHADER);
    //指定Shader源码
    glShaderSource(vertex_shader, 1, &vertex_shader_text, NULL);
    //编译Shader
    glCompileShader(vertex_shader);
    //获取编译结果
    GLint compile_status=GL_FALSE;
    glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &compile_status);
    if (compile_status == GL_FALSE)
    {
        GLchar message[256];
        glGetShaderInfoLog(vertex_shader, sizeof(message), 0, message);
        std::cout<<"compile vs error:"<<message<<std::endl;
    }

    //创建片段Shader
    fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
    //指定Shader源码
    glShaderSource(fragment_shader, 1, &fragment_shader_text, NULL);
    //编译Shader
    glCompileShader(fragment_shader);
    //获取编译结果
    compile_status=GL_FALSE;
    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &compile_status);
    if (compile_status == GL_FALSE)
    {
        GLchar message[256];
        glGetShaderInfoLog(fragment_shader, sizeof(message), 0, message);
        std::cout<<"compile fs error:"<<message<<std::endl;
    }


    //创建GPU程序
    program = glCreateProgram();
    //附加Shader
    glAttachShader(program, vertex_shader);
    glAttachShader(program, fragment_shader);
    //Link
    glLinkProgram(program);
    //获取编译结果
    GLint link_status=GL_FALSE;
    glGetProgramiv(program, GL_LINK_STATUS, &link_status);
    if (link_status == GL_FALSE)
    {
        GLchar message[256];
        glGetProgramInfoLog(program, sizeof(message), 0, message);
        std::cout<<"link error:"<<message<<std::endl;
    }
}
```