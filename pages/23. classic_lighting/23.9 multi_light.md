## 23.9 多光源

前面介绍了方向光、点光源，游戏里一般是有环境光+1个方向光+多个点光源，这一节就来介绍如何添加多个光源。

提起多个，就想到用数组，那么首先要解决的问题就是，如何在片段Shader里，创建点光源的数组？

### 1. 在Shader中访问数组

在Shader中定义数组和C语言很相似，也是用中括号。

下面代码在Uniform Block中，定义了长度为2的点光源数组 `data` 。

```glsl
//灯光数组
layout(std140) uniform PointLightBlock {
    PointLight data[2];
}u_point_light_array;
```

访问数组元素也和C语言相似。

下面代码访问了点光源数组 `data` 的第0个元素。

```glsl
vec3 light_dir=normalize(u_point_light_array.data[0].pos - v_frag_pos);
```

灯光的效果是叠加的，所以在片段着色器中，对每一类型的灯光，要进行遍历，然后计算，然后叠加。

完整的片段Shader代码如下：

```glsl
//file:data/shader/multi_light.frag

#version 330 core

uniform sampler2D u_diffuse_texture;//颜色纹理

//环境光
struct Ambient {
    vec3  color;//环境光 alignment:12 offset:0
    float intensity;//环境光强度 alignment:4 offset:16
};

layout(std140) uniform AmbientBlock {
    Ambient data;
}u_ambient;

//方向光
struct DirectionalLight {
    vec3  dir;//方向 alignment:12 offset:0
    vec3  color;//颜色 alignment:12 offset:12
    float intensity;//强度 alignment:4 offset:24
};

#define DIRECTIONAL_LIGHT_MAX_NUM 2

layout(std140) uniform DirectionalLightBlock {
    DirectionalLight data[DIRECTIONAL_LIGHT_MAX_NUM];
}u_directional_light_array;

//点光
struct PointLight {
    vec3  pos;//位置 alignment:16 offset:0
    vec3  color;//颜色 alignment:12 offset:16
    float intensity;//强度 alignment:4 offset:28

    float constant;//点光衰减常数项 alignment:4 offset:32
    float linear;//点光衰减一次项 alignment:4 offset:36
    float quadratic;//点光衰减二次项 alignment:4 offset:40
};

#define POINT_LIGHT_MAX_NUM 2

//灯光数组
layout(std140) uniform PointLightBlock {
    PointLight data[POINT_LIGHT_MAX_NUM];
}u_point_light_array;

uniform vec3 u_view_pos;
//uniform float u_specular_highlight_intensity;//镜面高光强度
uniform sampler2D u_specular_texture;//颜色纹理
uniform float u_specular_highlight_shininess;//物体反光度，越高反光能力越强，高光点越小。

in vec4 v_color;//顶点色
in vec2 v_uv;
in vec3 v_normal;
in vec3 v_frag_pos;

layout(location = 0) out vec4 o_fragColor;
void main()
{
    //ambient
    vec3 ambient_color = u_ambient.data.color * u_ambient.data.intensity * texture(u_diffuse_texture,v_uv).rgb;
    vec3 total_diffuse_color;
    vec3 total_specular_color;

    //遍历方向光，计算效果，并叠加。
    for(int i=0;i<DIRECTIONAL_LIGHT_MAX_NUM;i++){
        //diffuse
        vec3 normal=normalize(v_normal);
        vec3 light_dir=normalize(-u_directional_light_array.data[i].dir);
        float diffuse_intensity = max(dot(normal,light_dir),0.0);
        vec3 diffuse_color = u_directional_light_array.data[i].color * diffuse_intensity * u_directional_light_array.data[i].intensity * texture(u_diffuse_texture,v_uv).rgb;

        //specular
        vec3 reflect_dir=reflect(-light_dir,v_normal);
        vec3 view_dir=normalize(u_view_pos-v_frag_pos);
        float spec=pow(max(dot(view_dir,reflect_dir),0.0),u_specular_highlight_shininess);
        float specular_highlight_intensity = texture(u_specular_texture,v_uv).r;//从纹理中获取高光强度
        vec3 specular_color = u_directional_light_array.data[i].color * spec * u_directional_light_array.data[i].intensity * texture(u_diffuse_texture,v_uv).rgb;

        total_diffuse_color=total_diffuse_color+diffuse_color;
        total_specular_color=total_specular_color+specular_color;
    }

    //遍历点光源，计算效果，并叠加。
    for(int i=0;i<POINT_LIGHT_MAX_NUM;i++){
        //diffuse
        vec3 normal=normalize(v_normal);
        vec3 light_dir=normalize(u_point_light_array.data[i].pos - v_frag_pos);
        float diffuse_intensity = max(dot(normal,light_dir),0.0);
        vec3 diffuse_color = u_point_light_array.data[i].color * diffuse_intensity * u_point_light_array.data[i].intensity * texture(u_diffuse_texture,v_uv).rgb;

        //specular
        vec3 reflect_dir=reflect(-light_dir,v_normal);
        vec3 view_dir=normalize(u_view_pos-v_frag_pos);
        float spec=pow(max(dot(view_dir,reflect_dir),0.0),u_specular_highlight_shininess);
        float specular_highlight_intensity = texture(u_specular_texture,v_uv).r;//从纹理中获取高光强度
        vec3 specular_color = u_point_light_array.data[i].color * spec * specular_highlight_intensity * texture(u_diffuse_texture,v_uv).rgb;

        // attenuation
        float distance=length(u_point_light_array.data[i].pos - v_frag_pos);
        float attenuation = 1.0 / (u_point_light_array.data[i].constant + u_point_light_array.data[i].linear * distance + u_point_light_array.data[i].quadratic * (distance * distance));

        total_diffuse_color=total_diffuse_color+diffuse_color*attenuation;
        total_specular_color=total_specular_color+specular_color*attenuation;
    }

    o_fragColor = vec4(ambient_color + total_diffuse_color + total_specular_color,1.0);
}
```

### 2. 设置灯光数组参数

#### 2.1 访问数组元素

要从逻辑代码中去设置Shader数组的值，需要对每一个元素进行设置。

怎么理解 每一个元素 这5个字？

仍然用点光源数组举例。

```glsl
//点光
struct PointLight {
    vec3  pos;//位置 alignment:16 offset:0
    vec3  color;//颜色 alignment:12 offset:16
    float intensity;//强度 alignment:4 offset:28

    float constant;//点光衰减常数项 alignment:4 offset:32
    float linear;//点光衰减一次项 alignment:4 offset:36
    float quadratic;//点光衰减二次项 alignment:4 offset:40
};

//灯光数组
layout(std140) uniform PointLightBlock {
    PointLight data[2];
}u_point_light_array;
```

这段代码在Uniform Block中定义了长度为2的数组，而数组类型本身是Struct。

那么要用如下的形式，先遍历数组，然后逐个设置Struct成员变量。

```c++
std::string uniform_block_member_name;

for(int i=0;i<2;i++)
{
    //设置颜色
    uniform_block_member_name=fmt::format("data[{}].color",i);
    UniformBufferObjectManager::UpdateUniformBlockSubData3f("u_point_light_array",uniform_block_member_name,color_);

    uniform_block_member_name=fmt::format("data[{}].intensity",light_id_);
    UniformBufferObjectManager::UpdateUniformBlockSubData1f("u_point_light_array",uniform_block_member_name,intensity_);

    ......

    uniform_block_member_name=fmt::format("data[{}].quadratic",light_id_);
    UniformBufferObjectManager::UpdateUniformBlockSubData1f("u_point_light_array",uniform_block_member_name,attenuation_quadratic_);
}
```

也就是说，逻辑代码只能访问到Shader最外层的、以layout/varying/uniform修饰的变量，如果这个变量是Struct，那么就需要构造字符串去访问。

如上面的点光源数组，逻辑代码只能访问到 `u_point_light_array` 这个 layout 修饰的变量，而对于数组中的某一个元素，就需要构造字符串了。

#### 2.2 Uniform Block的尺寸

```glsl
//灯光数组
layout(std140) uniform PointLightBlock {
    PointLight data[2];
}u_point_light_array;
```

Uniform Block中，定义了一个Struct数组。

回顾std140内存布局的规则：

```bash
N=4
1. float算1N
2. 单独vec3算4N
3. vec3跟vec3算4N
4. vec3后面跟float，满足4N，那么(vec3+float)就算3N(vec3)+float(1N)=4N
5. struct需要满足4N的倍数
6. strcut[]按struct单个规则，满足4N倍数
```

匹配到第6条，那么 `sizeof(PointLightBlock) = sizeof(PointLight) x 2`。

#### 2.3 记录Uniform Block结构

在`UniformBufferObjectManager`中，记录Uniform Block结构。

因为是数组，所以成员变量就要乘以数组元素个数了，Uniform Block尺寸也需要乘以数组元素个数。

```c++
//file:source/render_device/uniform_buffer_object_manager.cpp line:12

#define DIRECTIONAL_LIGHT_MAX_NUM 2 //最大方向光数量
#define POINT_LIGHT_MAX_NUM 2 //最大点光源数量

std::vector<UniformBlockInstanceBindingInfo> UniformBufferObjectManager::kUniformBlockInstanceBindingInfoArray={
        ......
        {"u_directional_light_array","DirectionalLightBlock",32*DIRECTIONAL_LIGHT_MAX_NUM,1,0},
        {"u_point_light_array","PointLightBlock",48*POINT_LIGHT_MAX_NUM,2,0}
};

std::unordered_map<std::string,UniformBlock> UniformBufferObjectManager::kUniformBlockMap;

void UniformBufferObjectManager::Init(){
    ......

    //方向光
    kUniformBlockMap["DirectionalLightBlock"]={{}};
    {
        std::vector<UniformBlockMember>& uniform_block_member_vec=kUniformBlockMap["DirectionalLightBlock"].uniform_block_member_vec_;
        for(int i=0;i<POINT_LIGHT_MAX_NUM;i++){
            uniform_block_member_vec.push_back({fmt::format("data[{}].dir",i),32*i+0,sizeof(glm::vec3)});
            uniform_block_member_vec.push_back({fmt::format("data[{}].color",i),32*i+16,sizeof(glm::vec3)});
            uniform_block_member_vec.push_back({fmt::format("data[{}].intensity",i),32*i+28,sizeof(float)});
        }
    }

    //点光源数组
    kUniformBlockMap["PointLightBlock"]={{}};
    {
        std::vector<UniformBlockMember>& uniform_block_member_vec=kUniformBlockMap["PointLightBlock"].uniform_block_member_vec_;
        for(int i=0;i<POINT_LIGHT_MAX_NUM;i++){
            uniform_block_member_vec.push_back({fmt::format("data[{}].pos",i),48*i+0,sizeof(glm::vec3)});
            uniform_block_member_vec.push_back({fmt::format("data[{}].color",i),48*i+16,sizeof(glm::vec3)});
            uniform_block_member_vec.push_back({fmt::format("data[{}].intensity",i),48*i+28,sizeof(float)});
            uniform_block_member_vec.push_back({fmt::format("data[{}].constant",i),48*i+32,sizeof(float)});
            uniform_block_member_vec.push_back({fmt::format("data[{}].linear",i),48*i+36,sizeof(float)});
            uniform_block_member_vec.push_back({fmt::format("data[{}].quadratic",i),48*i+40,sizeof(float)});
        }
    }
}
```

#### 2.4 更新UBO

定义变量 `unsigned short light_id_;` 来作为光源数组的下标。

点光源更新UBO。

```c++
//source/lighting/point_light.cpp line:36

void PointLight::set_color(glm::vec3 color){
    Light::set_color(color);
    std::string uniform_block_member_name=fmt::format("data[{}].color",light_id_);
    UniformBufferObjectManager::UpdateUniformBlockSubData3f("u_point_light_array",uniform_block_member_name,color_);
};

void PointLight::set_intensity(float intensity){
    Light::set_intensity(intensity);
    std::string uniform_block_member_name=fmt::format("data[{}].intensity",light_id_);
    UniformBufferObjectManager::UpdateUniformBlockSubData1f("u_point_light_array",uniform_block_member_name,intensity_);
};

void PointLight::set_attenuation_constant(float attenuation_constant){
    attenuation_constant_ = attenuation_constant;
    std::string uniform_block_member_name=fmt::format("data[{}].constant",light_id_);
    UniformBufferObjectManager::UpdateUniformBlockSubData1f("u_point_light_array",uniform_block_member_name,attenuation_constant_);
}

void PointLight::set_attenuation_linear(float attenuation_linear){
    attenuation_linear_ = attenuation_linear;
    std::string uniform_block_member_name=fmt::format("data[{}].linear",light_id_);
    UniformBufferObjectManager::UpdateUniformBlockSubData1f("u_point_light_array",uniform_block_member_name,attenuation_linear_);
}

void PointLight::set_attenuation_quadratic(float attenuation_quadratic){
    attenuation_quadratic_ = attenuation_quadratic;
    std::string uniform_block_member_name=fmt::format("data[{}].quadratic",light_id_);
    UniformBufferObjectManager::UpdateUniformBlockSubData1f("u_point_light_array",uniform_block_member_name,attenuation_quadratic_);
}

void PointLight::Update(){
    glm::vec3 light_position=game_object()->GetComponent<Transform>()->position();
    std::string uniform_block_member_name=fmt::format("data[{}].pos",light_id_);
    UniformBufferObjectManager::UpdateUniformBlockSubData3f("u_point_light_array",uniform_block_member_name,light_position);
}
```