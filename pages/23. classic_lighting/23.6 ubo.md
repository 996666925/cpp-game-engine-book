## 23.6 Uniform Buffer Object

你有没有和我一样，觉得很奇怪。

为什么每渲染一个物体，都需要上传一次MVP矩阵？

```c++
//file:source/renderer/mesh_renderer.cpp line:123

void MeshRenderer::Render() {
    ......

    shader->Active();
    {
        ......

        //上传mvp矩阵
        RenderTaskProducer::ProduceRenderTaskSetUniformMatrix4fv(shader_program_handle, "u_model", false,model);
        RenderTaskProducer::ProduceRenderTaskSetUniformMatrix4fv(shader_program_handle, "u_view", false,view);
        RenderTaskProducer::ProduceRenderTaskSetUniformMatrix4fv(shader_program_handle, "u_projection", false,projection);

        //上传Texture
        ......
    }
}
```

整个游戏场景中所有的模型，都是使用相同的灯参数，为什么每一帧、绘制每个模型都要设置一次灯光参数？

```lua
function LoginScene:Update()
    ......

    --设置环境光颜色和强度
    self.material_:SetUniform3f("u_ambient_light_color",self.environment_:ambient_color())
    self.material_:SetUniform1f("u_ambient_light_intensity",self.environment_:ambient_color_intensity())
    --设置灯光位置、颜色、强度
    self.material_:SetUniform3f("u_light_pos",glm.vec3(0,0,20))
    self.material_:SetUniform3f("u_light_color",glm.vec3(1.0,1.0,1.0))
    self.material_:SetUniform1f("u_light_intensity",1.0)
    --设置观察者世界坐标(即相机位置)
    local camera_position=self.go_camera_:GetComponent(Transform):position()
    self.material_:SetUniform3f("u_view_pos",camera_position)
    --设置物体反射度、高光强度
    --self.material_:SetUniform1f("u_specular_highlight_intensity",1.0)
    self.material_:SetUniform1f("u_specular_highlight_shininess",32.0)
end
```

能不能做到，只上传设置一次，修改的时候更新？

### 1. Uniform的作用范围

在顶点着色器中，使用 `uniform` 修饰了MVP 3个矩阵。

```glsl
//file:data/shader/light_ubo.vert

#version 330 core

uniform mat4 u_model;
uniform mat4 u_view;
uniform mat4 u_projection;

......
```

GPU程序是并行的，`uniform` 修饰的变量，表示在这一次绘制中，是唯一的、不变的。

但是它不是跨GPU程序的。

当这一次绘制完成后，`uniform`变量就无效了。

使用相同Shader，再绘制另一个物体，需要重新设置。

`uniform`变量类似于C++的成员变量，类实例A 中的成员变量，不能作用到 类实例B。

在C++中，可以使用 static 变量，让它全局生效。

或者申请一块内存buffer，使用指针访问，只要不删除，那这块内存buffer也是全局生效的。

在OpenGL里，也可以申请这样一块Buffer，用来存储 `uniform`变量，它叫做 Uniform Buffer Object，简称UBO。

### 2. Uniform Buffer Object

### 2.1 定义UBO结构

实现环境光和镜面高光光照模型，需要设置大量的`uniform`变量。

可以将这些变量组织成`struct`形式，存储到UBO中。

```glsl
//file:data/shader/light_ubo.frag line:5

struct Ambient{
    vec3  color;//环境光 alignment:12 offset:0
    float intensity;//环境光强度 alignment:4 offset:16
};

//环境光
layout(std140) uniform AmbientBlock {
    Ambient data;
}u_ambient;

struct Light {
    vec3  pos;//位置 alignment:12 offset:0
    vec3  color;//颜色 alignment:12 offset:12
    float intensity;//强度 alignment:4 offset:24
};

//灯光
layout(std140) uniform LightBlock {
    Light data;
}u_light;
```

### 2.1 创建UBO

OpenGL创建Buffer的流程大致相同：
1. glGenBuffers 创建Buffer
2. glBindBuffer 绑定Buffer来使用
3. glBufferData 上传数据到Buffer

创建VBO是使用这套流程，创建UBO也是这套流程。

使用Buffer的流程却有所不同，VBO使用流程如下：
1. glBindBuffer 绑定Buffer来使用
2. 将Buffer与Shader中的变量关联
3. glDrawElements 绘制

而对于UBO，

```c++
void UniformBufferObjectManager::CreateUniformBufferObject(){
    for (int i = 0; i < kUniformBlockInstanceBindingInfoArray.size(); ++i) {
        UniformBlockInstanceBindingInfo& uniform_block_binding_info=kUniformBlockInstanceBindingInfoArray[i];
        glGenBuffers(1, &uniform_block_binding_info.uniform_buffer_object_);__CHECK_GL_ERROR__
        glBindBuffer(GL_UNIFORM_BUFFER, uniform_block_binding_info.uniform_buffer_object_);__CHECK_GL_ERROR__
        //先不填数据
        unsigned short uniform_block_data_size=uniform_block_binding_info.uniform_block_size_;
        glBufferData(GL_UNIFORM_BUFFER, uniform_block_data_size, NULL, GL_STATIC_DRAW);__CHECK_GL_ERROR__

        //串联 UBO 和 binding point 绑定
        glBindBufferBase(GL_UNIFORM_BUFFER, uniform_block_binding_info.binding_point_, uniform_block_binding_info.uniform_buffer_object_);__CHECK_GL_ERROR__

        glBindBuffer(GL_UNIFORM_BUFFER, 0);__CHECK_GL_ERROR__
    }
}
```


对场景中的每个物体，都受到同一个环境光和灯光影响。

那每当要渲染一个物体时，都需要对物体的shader程序，去设置环境光和灯光的参数。

有10个物体(不同shader程序)，就需要设置10次。

那能不能将环境光和灯光提取出来单独存放到一个buffer，让这10个物体的shader程序去buff里读取呢？

uniform buffer object来做这个。


ubo instance name的使用方式
https://www.khronos.org/opengl/wiki/Program_Introspection#Interface_block_member_naming

https://stackoverflow.com/questions/24806538/instance-name-with-uniform-blocks-ubo-does-not-work-using-opengl-glsl